print('Задача 1. Урок информатики 2')


# В прошлый раз учитель написал программу,
# которая выводит числа в формате плавающей точки, однако он вспомнил,
# что не учёл одну важную штуку: числа-то могут идти от нуля.
# 
# Задано положительное число x (x > 0).
# Ваша задача преобразовать его в формат плавающей точки,
# то есть x = a * 10 ** b, где 1 ≤ а < 10
# 
# Обратите внимание, что x теперь больше нуля, а не больше единицы.
# Обеспечьте контроль ввода.
# 
# Пример 1:
# 
# Введите число: 92345
# 
# Формат плавающей точки: x = 9.2345 * 10 ** 4
# 
# Пример 2:
# 
# Введите число: 0.0012
# Формат плавающей точки: x = 1.2 * 10 ** -3

print('Задача 1. Урок информатики 2')

# В прошлый раз учитель написал программу,
# которая выводит числа в формате плавающей точки, однако он вспомнил,
# что не учёл одну важную штуку: числа-то могут идти от нуля.
# 
# Задано положительное число x (x > 0).
# Ваша задача преобразовать его в формат плавающей точки,
# то есть x = a * 10 ** b, где 1 ≤ а < 10
# 
# Обратите внимание, что x теперь больше нуля, а не больше единицы.
# Обеспечьте контроль ввода.
# 
# Пример 1:
# 
# Введите число: 92345
# 
# Формат плавающей точки: x = 9.2345 * 10 ** 4
# 
# Пример 2:
# 
# Введите число: 0.0012
# Формат плавающей точки: x = 1.2 * 10 ** -3

def get_positive_float():
    while True:
        user_input = float(input("Введите положительное число: "))
        if user_input <= 0:
            print("Число должно быть больше нуля. Попробуйте снова.")
            continue
        break


    mantissa = user_input
    exponent = 0
    if user_input < 1:
        while mantissa < 1:
            mantissa *= 10
            exponent -= 1
    else:
        while mantissa >= 10:
            mantissa /= 10
            exponent += 1

    print(f"Формат плавающей точки: x = {mantissa} * 10 ** {exponent}")


get_positive_float()




print('Задача 2. Функция максимума')

# Юра пишет различные полезные функции для Python, чтобы остальным программистам стало проще работать. Он захотел написать функцию, 
# которая будет находить максимум из перечисленных чисел. Функция для нахождения максимума из двух чисел у него уже есть. 
# Юра задумался: может быть, её можно как-то использовать для нахождения максимума уже от трёх чисел?

# Помогите Юре написать программу, которая находит максимум из трёх чисел.
# Для этого используйте только функцию нахождения максимума из двух чисел.

# По итогу в программе должны быть реализованы две функции:
# 1) maximum_of_two — функция принимает два числа и возвращает одно (наибольшее из двух);
# 2) maximum_of_three — функция принимает три числа и возвращает одно (наибольшее из трёх); 
# при этом она должна использовать для сравнений первую функцию maximum_of_two.


def get_maximum_of_two(first_number, second_number):
    """Возвращает максимум из двух чисел."""
    if first_number > second_number:
        return first_number
    else:
        return second_number


def get_maximum_of_three(first_number, second_number, third_number):
    """Возвращает максимум из трех чисел, используя get_maximum_of_two."""
    max_of_first_two = get_maximum_of_two(first_number, second_number)
    if max_of_first_two > third_number:
        return max_of_first_two
    else:
        return third_number


number1 = float(input("Введите первое число: "))
number2 = float(input("Введите второе число: "))
number3 = float(input("Введите третье число: "))


maximum_value = get_maximum_of_three(number1, number2, number3)
print(f"Максимальное число: {maximum_value}")



print('Задача 3. Число наоборот 2')


# Пользователь вводит два числа — N и K.
# Напишите программу,
# которая заменяет каждое число на число,
# которое получается из исходного записью его цифр в обратном порядке,
# затем складывает их,
# снова переворачивает и выводит ответ на экран.

# Пример: 

# Введите первое число: 102
# Введите второе число: 123
 
 
# Первое число наоборот: 201
# Второе число наоборот: 321
 
# Сумма: 522
# Сумма наоборот: 225

def reverse_number(num):
    """Возвращает число с перевернутыми цифрами."""
    return int(str(num)[::-1])

# Ввод чисел от пользователя
number_n = int(input("Введите первое число: "))
number_k = int(input("Введите второе число: "))

# Переворот чисел
reversed_n = reverse_number(number_n)
reversed_k = reverse_number(number_k)

# Сложение
sum_of_reversed = reversed_n + reversed_k

# Переворот суммы
reversed_sum = reverse_number(sum_of_reversed)

# Вывод результатов
print(f"Первое число наоборот: {reversed_n}")
print(f"Второе число наоборот: {reversed_k}")
print(f"Сумма: {sum_of_reversed}")
print(f"Сумма наоборот: {reversed_sum}")


print('Задача 4. Недоделка 2')

# Вы всё так же работаете в конторе по разработке игр и смотрите различные программы прошлого горе-программиста.
#  В одной из игр для детей, связанной с мультяшной работой с числами, вам нужно было написать код согласно следующим условиям:
#  программа получает на вход два числа; в первом числе должно быть не менее трёх цифр, во втором — не менее четырёх, 
# иначе программа выдаёт ошибку. Если всё нормально, то в каждом числе первая и последняя цифры меняются местами,
# а затем выводится их сумма.

# И тут вы натыкаетесь на программу, которая была написана предыдущим программистом и которая как раз решает такую задачу. 
# Однако старший программист попросил вас немного переписать этот код, чтобы он не выглядел так ужасно. 
# Да и вам самим становится, мягко говоря, не по себе от него.

# Постарайтесь разделить логику кода на три отдельные логические части (функции):
# count_numbers — получает число и возвращает количество цифр в числе;
# change_number — получает число, меняет в нём местами первую и последнюю цифры и возвращает изменённое число;
# main — функция ничего не получает на вход, внутри она запрашивает нужные данные от пользователя, 
# выполняет дополнительные проверки и вызывает функции 1 и 2 для выполнения задачи (проверки и изменения двух чисел).

# Разбейте приведённую ниже программу на функции. Повторений кода должно быть как можно меньше.
#  Также сделайте, чтобы в основной части программы был только ввод чисел, затем изменённые числа и вывод их суммы.


def count_numbers(number):
    """Возвращает количество цифр в числе."""
    count = 0
    temp = number
    while temp > 0:
        count += 1
        temp //= 10
    return count

def change_number(number):
    """Меняет местами первую и последнюю цифры числа."""
    num_str = str(number)
    # Изменяем местами первую и последнюю цифры
    if len(num_str) > 1:
        changed_num_str = num_str[-1] + num_str[1:-1] + num_str[0]
        return int(changed_num_str)
    return number  # Если число состоит из одной цифры

def main():
    """Основная функция для выполнения программы."""
    first_number = int(input("Введите первое число (не менее 3 цифр): "))
    first_digit_count = count_numbers(first_number)

    if first_digit_count < 3:
        print("В первом числе меньше трёх цифр.")
        return

    first_number = change_number(first_number)
    print('Изменённое первое число:', first_number)

    second_number = int(input("\nВведите второе число (не менее 4 цифр): "))
    second_digit_count = count_numbers(second_number)

    if second_digit_count < 4:
        print("Во втором числе меньше четырёх цифр.")
        return

    second_number = change_number(second_number)
    print('Изменённое второе число:', second_number)

    print('\nСумма чисел:', first_number + second_number)

# Запуск программы
main()



print('Задача 5. Маятник ')

# Известно, что амплитуда качающегося маятника с каждым разом затухает
# на 8,4% от амплитуды прошлого колебания. 
# Если качнуть маятник,
# то, строго говоря, он не остановится никогда, 
# просто амплитуда будет постоянно уменьшаться до тех пор, 
# пока мы не сочтём такой маятник остановившимся. 
 
# Напишите программу, 
# определяющую, сколько раз качнётся маятник, прежде чем он, по нашему мнению, остановится. 
 
# Программа получает на вход
# начальную амплитуду колебания в сантиметрах 
# и конечную амплитуду его колебаний,
# которая считается остановкой маятника. 

# Обеспечьте контроль ввода.

# Пример:

# Введите начальную амплитуду: 1
# Введите амплитуду остановки: 0.1
 
# Маятник считается остановившимся через 27 колебаний

def count_swinging_amplitudes(initial_amplitude, stopping_amplitude):
    """Определяет количество колебаний маятника до остановки."""
    swing_count = 0
    while initial_amplitude > stopping_amplitude:
        initial_amplitude *= 0.916  # Затухание на 8.4% (0.916 = 1 - 0.084)
        swing_count += 1
    return swing_count

def main():
    """Основная функция для выполнения программы."""
    try:
        initial_amplitude = float(input("Введите начальную амплитуду (см): "))
        stopping_amplitude = float(input("Введите амплитуду остановки (см): "))

        if initial_amplitude <= 0 or stopping_amplitude <= 0:
            print("Амплитуда должна быть положительным числом.")
            return

        if stopping_amplitude >= initial_amplitude:
            print("Амплитуда остановки должна быть меньше начальной амплитуды.")
            return

        swings = count_swinging_amplitudes(initial_amplitude, stopping_amplitude)
        print(f"Маятник считается остановившимся через {swings} колебаний")

    except ValueError:
        print("Ошибка ввода. Пожалуйста, введите числовые значения.")

# Запуск программы
main()


print('Задача 6. Яйца')

# В рамках программы колонизации Марса
# компания «Спейс Инжиниринг» вывела особую породу черепах,
# которые, по задумке, должны размножаться, откладывая яйца в марсианском грунте.
# Откладывать яйца слишком близко к поверхности опасно из-за радиации,
# а слишком глубоко — из-за давления грунта и недостатка кислорода.
# Вообще, факторов очень много,
# но специалисты проделали большую работу и предположили,
# что уровень опасности для черепашьих яиц рассчитывается по формуле
# D = x**3 − 3x**2 − 12x + 10,
# где x — глубина кладки в метрах,
# а D — уровень опасности в условных единицах.
# 
# Для тестирования гипотезы
# нужно взять пробу грунта на безопасной, согласно формуле, глубине.
# 
# Напишите программу,
# находящую такое значение глубины "х", при котором уровень опасности как можно более близок к нулю.
# На вход программе подаётся максимально допустимое отклонение уровня опасности от нуля,
# а программа должна рассчитать приблизительное значение "х",
# удовлетворяющее этому отклонению.
# 
# Известно, что глубина точно больше нуля и меньше четырёх метров.
# 
# Обеспечьте контроль ввода.
# 
# Пример:
# Введите максимально допустимый уровень опасности: 0.01
# 
# Приблизительная глубина безопасной кладки: 0.732421875 м


def find_danger_level(x):
    """Вычисляет уровень опасности по заданной формуле."""
    return x**3 - 3 * x**2 - 12 * x + 10

def find_safe_depth(tolerance):
    """Находит глубину, при которой уровень опасности близок к нулю."""
    low = 0.0
    high = 4.0
    best_x = None

    while low <= high:
        mid = (low + high) / 2
        danger = find_danger_level(mid)

        if abs(danger) <= tolerance:
            best_x = mid
            break  # Нашли глубину с приемлемым уровнем опасности

        # Если уровень опасности больше нуля, ищем в меньшей глубине
        if danger > 0:
            high = mid - 0.001
        else:  # Если уровень опасности меньше нуля, ищем в большей глубине
            low = mid + 0.001
            
        best_x = mid  # Сохраняем последнее значение, если не нашли точное решение

    return best_x

def main():
    """Основная функция для выполнения программы."""
    try:
        tolerance = float(input("Введите максимально допустимый уровень опасности: "))

        if tolerance <= 0:
            print("Допустимый уровень опасности должен быть положительным числом.")
            return

        safe_depth = find_safe_depth(tolerance)

        if safe_depth is not None:
            print(f"Приблизительная глубина безопасной кладки: {safe_depth:.9f} м")
        else:
            print("Не удалось найти безопасную глубину.")

    except ValueError:
        print("Ошибка ввода. Пожалуйста, введите числовое значение.")

# Запуск программы
main()

