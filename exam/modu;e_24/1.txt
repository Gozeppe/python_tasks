Задача 1. Драка
Что нужно сделать
Вы работаете в команде разработчиков мобильной игры, и вам досталась часть от ТЗ заказчика.

Есть два юнита, каждый называется «Воин». Каждому устанавливается здоровье в 100 очков. Они бьют друг друга в случайном порядке. Тот, кто бьёт, здоровье не теряет. У того, кого бьют, оно уменьшается на 20 очков от одного удара. После каждого удара надо выводить сообщение, какой юнит атаковал и сколько у противника осталось здоровья. Как только у кого-то заканчивается ресурс здоровья, программа завершается сообщением о том, кто одержал победу.

Реализуйте такую программу.

Что оценивается
Результат вычислений корректен.
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Сообщения о процессе получения результата осмысленны и понятны для пользователя.
Переменные, функции и собственные методы классов имеют значащие имена, не a, b, c, d.


Задача 2. Студенты
Что нужно сделать
Реализуйте модель с именем Student, содержащую поля «ФИ», «Номер группы», «Успеваемость» (список из пяти элементов). Затем создайте список из десяти студентов (данные о студентах можете придумать или запросить у пользователя) и отсортируйте список по возрастанию среднего балла. Выведите результат на экран.

Что оценивается
Результат вычислений корректен.
Input содержит корректные приглашения для ввода. 
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Сообщения о процессе получения результата осмысленны и понятны для пользователя.
Переменные, функции и собственные методы классов имеют значащие имена, не a, b, c, d.


Задача 3. Отцы, матери и дети
Что нужно сделать
Реализуйте два класса: «Родитель» и «Ребёнок». У родителя есть:

имя,
возраст,
список детей.
И он может:

сообщить информацию о себе,
успокоить ребёнка,
покормить ребёнка.
У ребёнка есть:

имя,
возраст (должен быть меньше возраста родителя хотя бы на 16 лет),
состояние спокойствия,
состояние голода.
Реализация состояний — на ваше усмотрение. Это может быть и простой «флаг», и словарь состояний, и что-то поинтереснее.

Что оценивается
Результат вычислений корректен.
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Переменные, функции и собственные методы классов имеют значащие имена, не a, b, c, d.


Задача 4. Магия
Что нужно сделать
Для одной игры необходимо реализовать механику магии, где при соединении двух элементов получается новый. У нас есть четыре базовых элемента: «Вода», «Воздух», «Огонь», «Земля». Из них получаются новые: «Шторм», «Пар», «Грязь», «Молния», «Пыль», «Лава».

Таблица преобразований:

Вода + Воздух = Шторм;
Вода + Огонь = Пар;
Вода + Земля = Грязь;
Воздух + Огонь = Молния;
Воздух + Земля = Пыль;
Огонь + Земля = Лава.
Напишите программу, которая реализует все эти элементы. Каждый элемент необходимо организовать как отдельный класс. Если результат не определён, то возвращается None.

Примечание: сложение объектов можно реализовывать через магический метод __add__, вот пример использования:

class ExampleOne:

    def __add__(self, other):

        return ExampleTwo()

class ExampleTwo:

    answer = 'сложили два класса и вывели'

first_example = ExampleOne()

second_example = ExampleTwo()

result = first_example + second_example

print(result.answer)

Дополнительно: придумайте свой элемент (или элементы) и реализуйте его взаимодействие с остальными.

Что оценивается
Результат вычислений корректен.
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Переменные, функции и собственные методы классов имеют значащие имена, не a, b, c, d.


Задача 5. Совместное проживание
Что нужно сделать
Чтобы понять, стоит ли ему жить с кем-то или лучше остаться в гордом одиночестве, Артём решил провести необычное исследование. Для этого он реализовал модель человека и модель дома.

Человек может (должны быть такие методы):

есть (+ сытость, − еда);
работать (− сытость, + деньги);
играть (− сытость);
ходить в магазин за едой (+ еда, − деньги);
прожить один день (выбирает одно действие согласно описанному ниже приоритету и выполняет его).
У человека есть (должны быть такие атрибуты):

имя,
степень сытости (изначально 50),
дом.
В доме есть: 

холодильник с едой (изначально 50 еды), 
тумбочка с деньгами (изначально 0 денег).
Если сытость человека становится меньше нуля, человек умирает.

Логика действий человека определяется следующим образом:

Генерируется число кубика от 1 до 6.
Если сытость < 20, то нужно поесть.
Иначе, если еды в доме < 10, то сходить в магазин.
Иначе, если денег в доме < 50, то работать.
Иначе, если кубик равен 1, то работать.
Иначе, если кубик равен 2, то поесть.
Иначе играть.
По такой логике эксперимента человеку надо прожить 365 дней.

Реализуйте такую программу и создайте двух людей, живущих в одном доме. Проверьте работу программы несколько раз. 

Советы и рекомендации
В большинстве случаев классы нужны не для того, чтобы с ними работать напрямую, а чтобы с их помощью создавать объекты, которые будут содержать необходимую информацию и смогут вызывать нужные методы. Наш случай не исключение: вам не нужно работать напрямую с классами, работайте с объектами, которые создаются при помощи этих классов.
Глобальные переменные создают зависимости. Чем больше класс обращается к переменным, созданным снаружи класса, тем больше в классе появляется неопределённости (для работы с классом вам придётся отслеживать значения всех этих переменных). По возможности передавайте нужные данные в объект и записывайте их в атрибуты вместо обращения к глобальной переменной.
Что оценивается
Результат вычислений корректен.
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Код можно использовать для создания нескольких людей, живущих в отдельных домах.
Сообщения о процессе получения результата осмысленны и понятны для пользователя.
Переменные, функции и собственные методы классов имеют значащие имена, не a, b, c, d.


Задача 6. Крестики-нолики
Что нужно сделать
Создайте программу, которая реализует игру «Крестики-нолики».

Для этого напишите:

1. Класс, который будет описывать поле игры.

class Board:

    #  Класс поля, который создаёт у себя экземпляры клетки.

    #  Пусть класс хранит информацию о состоянии поля (это может быть список из девяти элементов).

    #  Помимо этого, класс должен содержать методы:

    #  «Изменить состояние клетки». Метод получает номер клетки и, если клетка не занята, меняет её состояние. Если состояние удалось изменить, метод возвращает True, иначе возвращается False.

    #  «Проверить окончание игры». Метод не получает входящих данных, но возвращает True/False. True — если один из игроков победил, False — если победителя нет.

2. Класс, который будет описывать одну клетку поля:

class Cell:

    #  Клетка, у которой есть значения:

    #  занята она или нет;

    #  номер клетки;

    #  символ, который клетка хранит (пустая, крестик, нолик).

3. Класс, который описывает поведение игрока:

class Player:

    #  У игрока может быть:

    #  имя,

    #  количество побед.

    #  Класс должен содержать метод:

    #   «Сделать ход». Метод ничего не принимает и возвращает ход игрока (номер клетки). Введённый номер нужно обязательно проверить.

4. Класс, который управляет ходом игры:

class Game:    

    # класс «Игры» содержит атрибуты:

    # состояние игры,

    # игроки,

    # поле.

    # А также методы:

    # Метод запуска одного хода игры. Получает одного из игроков, запрашивает у игрока номер клетки, изменяет поле, проверяет, выиграл ли игрок. Если игрок победил, возвращает True, иначе False.

    # Метод запуска одной игры. Очищает поле, запускает цикл с игрой, который завершается победой одного из игроков или ничьей. Если игра завершена, метод возвращает True, иначе False.

    # Основной метод запуска игр. В цикле запускает игры, запрашивая после каждой игры, хотят ли игроки продолжать играть. После каждой игры выводится текущий счёт игроков.

Что оценивается
Результат вычислений корректен.
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Сообщения о процессе получения результата осмысленны и понятны для пользователя.
Переменные, функции и собственные методы классов имеют значащие имена, не a, b, c, d.


Задача 7. Матрицы
Контекст 
Вы стажируетесь в лаборатории искусственного интеллекта, в ней вам поручили разработать класс Matrix для обработки и анализа данных. Ваш класс должен предоставлять функциональность для выполнения основных операций с матрицами, таких как сложение, вычитание, умножение и транспонирование. Это будет полезно для обработки и структурирования больших объёмов данных, которые используются в обучении нейронных сетей.

Задача 
Создайте класс Matrix для работы с матрицами. 
Реализуйте методы:
сложения,
вычитания,
умножения,
транспонирования матрицы.
Создайте несколько экземпляров класса Matrix и протестируйте реализованные операции.
Советы
Методы сложения/вычитания/умножения должны получать параметром другую матрицу (объект класса Matrix) и выполнять указанное действие над своей и этой другой матрицей. Например, метод сложения должен получить параметром новую матрицу и сложить её со своей текущей.
Метод транспонирования не должен ничего получать, он должен работать исключительно со своей матрицей.
Транспонирование — это алгоритм, при котором строки матрицы меняются местами с её столбцами:


Алгоритм транспонирования матрицы можно расписать следующим образом:
Создать новую матрицу result с размерами, обратными размерам исходной матрицы. Количество строк новой матрицы равно количеству столбцов исходной, а количество столбцов новой матрицы равно количеству строк исходной.
Пройтись по каждому элементу исходной матрицы. Для каждого элемента с индексами (i, j):
Поместить значение этого элемента (i, j) в ячейку с индексами (j, i) новой матрицы. То есть транспонирование происходит с помощью обмена индексов местами.
После завершения цикла новая матрица result будет содержать транспонированную матрицу, которую можно вернуть.
Пример:

# Создание экземпляров класса Matrix
m1 = Matrix(2, 3)
m1.data = [[1, 2, 3], [4, 5, 6]]

m2 = Matrix(2, 3)
m2.data = [[7, 8, 9], [10, 11, 12]]

# Тестирование операций
print("Матрица 1:")
print(m1)

print("Матрица 2:")
print(m2)

print("Сложение матриц:")
print(m1.add(m2))

print("Вычитание матриц:")
print(m1.subtract(m2))

m3 = Matrix(3, 2)
m3.data = [[1, 2], [3, 4], [5, 6]]

print("Умножение матриц:")
print(m1.multiply(m3))

print("Транспонирование матрицы 1:")
print(m1.transpose())
Вывод
Матрица 1:

1    2    3

4    5    6



Матрица 2:

7    8    9

10    11    12



Сложение матриц:

8    10    12

14    16    18



Вычитание матриц:

-6    -6    -6

-6    -6    -6



Умножение матриц:

22    28

49    64



Транспонирование матрицы 1:

1    4

2    5

3    6



Что оценивается в практической работе
Работа сдана через GitLab.
Структура папок и файлов репозитория соответствует репозиторию python_basic.
Все задачи выполнены в соответствующих папках и файлах main.py.
Описания коммитов осмысленны и понятны: 111, done, «я сделалъ» — неверно; added m15 homework, 14.3 fix: variables naming — верно.
Использованы именованные индексы, не просто i (подробнее — в видео 7.2).
Использованы правильные числа, без дополнительных действий со стороны пользователя, без +1 (подробнее — в видео 7.4).
Правильно оформлен input, без пустого приветствия для ввода (подробнее — в видео 2.3).
Переменные и функции имеют значащие имена, не только a, b, c, d (подробнее — в видео 2.3).
Есть пробелы после запятых и при бинарных операциях.
Нет пробелов после имён функций и перед скобками: print (), input () — неверно, print() — верно.
Правильно оформлены блоки if-elif-else, циклы и функции, отступы одинаковы во всех блоках одного уровня.
Все входные и выходные файлы называются так, как указано в задачах.
Работа с файлами осуществляется с помощью контекстного менеджера with.
Для обработки исключений используются блоки try-except.
Модели реализованы в стиле ООП, основной функционал описан в методах классов и отдельных функциях.
Если классы вынесены в отдельный модуль, то импортируются определённые классы (запись вида from garden import * считается плохим тоном).


Рекомендации
Арифметические операции PEP8 остаются в приоритете. Необходимо вводить and, or.
Руководство по стилю Python PEP8 на английском языке.
Руководство по стилю Python PEP8 на русском языке.
Список встроенных функций.
